- [ ] move grar out of domain towards grar project (except for interfaces and domain stuff)
- [ ] see what lives in domain -> framework and move stuff towards contracts, cmd handling, or other projects. be critical about this, and where it belongs, might be other projects as well.
  ANSWER: Domain should only contain: core business logic, entities, value objects, domain events, business rules.
  Move to Framework: infrastructure concerns, technical implementations, cross-cutting concerns
  Move to Contracts: DTOs, interfaces defining layer boundaries, API contracts
  Move to other projects: integration-specific code, infrastructure implementations
  Action: Analyze current domain structure to identify misplaced items

- [ ] jsonld-context: in domain, or in contracts?
  ANSWER: Move to CONTRACTS - JSON-LD contexts are part of API contract defining how external systems interact.
  Only keep in domain if it's core business concept integral to association modeling.
  If purely for serialization, consider Infrastructure or dedicated serialization project.

- [ ] kbo, magda in domain: where do these really belong?
  ANSWER: Move to INTEGRATION PROJECTS (AssociationRegistry.Integrations.Kbo, AssociationRegistry.Integrations.Magda)
  Domain should only contain interfaces defining what domain needs (Dependency Inversion)
  Actual implementations, DTOs, integration logic belong in dedicated integration projects
  Current refactoring already moving KBO items to CommandHandling layer - good start

- [x] notifications: let's make a separate csproj for this, and move it out of domain. Everything should go there, except maybe the implementations of the IMessage, which belong near the specific command handler folders i think.
  ANSWER: Correct approach. Create AssociationRegistry.Notifications project for:
  - Notification infrastructure (publishers, handlers, configuration)
  - Keep IMessage implementations near command handlers (domain-related)
  - Provides clear separation of concerns and reusability

- [x] exceptionmessages, logging resx files: move to contracts, or not?
  ANSWER: Depends on exception type:
  - Domain-specific exceptions (business rule violations): Keep in DOMAIN
  - API error messages: Move to CONTRACTS (part of API contract)
  - Technical/infrastructure exceptions: Move to respective infrastructure projects
  - Consider AssociationRegistry.Common for cross-cutting resources

- [ ] rename any integrations projects to Association.Integrations.*, and any infrastructure projects to Association.Infrastructure.*. group them in folders
  ANSWER: Good standardization. Structure:
  /Integrations/ - All AssociationRegistry.Integrations.* projects
  /Infrastructure/ - All AssociationRegistry.Infrastructure.* projects
  /Core/ - Domain and Contracts
  /Hosts/ - Executable projects
  Improves discoverability and organization

- [ ] take a look at the setup of the program files for the hosts. Stuff like setting up marten, wolverine should probably be extracted more granular extension methods, after which we can move them to the integrations or infrastructure projects.
  ANSWER: Extract to extension methods in appropriate projects:
  - Marten setup → AssociationRegistry.Infrastructure.Persistence
  - Wolverine setup → AssociationRegistry.Infrastructure.Messaging
  - Keep Program.cs minimal, focused on composition only
  - Improves testability and reusability

- [ ] look at service registrations in the host projects, and see if some of them belong together in existing projects.
  ANSWER: Group by functionality:
  - Repository registrations → Persistence project
  - Message handler registrations → Messaging project
  - External service registrations → Integration projects
  - Create extension methods for related registrations
  - Establish clear registration hierarchy to avoid duplication
# General rules
- One line commit messages, no mention of ai.
- Always run tests before committing.
- Update the architecture diagram in the docs folder when making changes to the architecture.
- Update the refactoring readme with what you did, and why you did it.
- update the checkboxes in this todo.txt file when you complete a task.
